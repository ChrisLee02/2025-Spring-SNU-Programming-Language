1. 돌아보기, 내다보기
- 지금까지 배운 것: 프로그램의 구조와 의미(Abstract syntax, Semantics), 그것을 표현하기 위한 귀납법과 그 철학을 따르는 프로그래밍 방법.
- 앞으로 배울 것: 기계 중심의 언어와 값 중심의 언어

2. 프로그래밍 언어의 두 토양: 튜링 기계와 람다 계산
- 튜링 기계를 전자 부품으로 구현한 컴퓨터 - 종이 테이프, 상태, 규칙표로 구성된,,
- 튜링 기계로 임의의 튜링 기계를 돌릴 수 있다. 보편만능의 기계
- 튜링 기계를 돌리기 위한 기계 중심의 언어(imperative language)는 종이 테이프에 뭘 쓰고 바꾸고 하는 방식으로 동작할 수 밖에,, C언어는 return 값보다는 인자로 전달한 포인터의 값을 변경하는 식으로 작동하잖아?
- 1936년 같은 시기, 람다 계산법이 등장함
- 람다 계산법에 기초한 값 중심의 언어(applicative language)에는 기계가 없다. 상태의 변화도 없다.
- 값을 내놓을 뿐,,
- 두 패러다임의 좋은 점들이 섞이면서 프로그래밍 하기 좋은 언어로 수렴해간다. 나비가 꽃을 향해 날아가듯,,

3. 기계중심의 언어
- 명령, 흐름, statement와 기계의 상태
- 주어진 메모리 M에 대해서 Expression은 값(V)을 계산하고, 메모리는 바꾸지 않음.
- 주어진 메모리 M에 대해서 Statement(명령문)는 메모리 M을 M'으로 변화시킨다.
- Syntactic object(E, S) -> 프로그램의 구조를 정의, Semantic object(M, v) -> 프로그램의 의미를 정의
- record를 함수로 표현하는 방법이 슬라이드에 나와있었음,, f[b/a] or f{a -> b}
- 전기적 레벨의 메모리 -> 주소를 받아서 0/1을 주거나 쓸 수 있는 회로 (Capacitor)
- 시스템 레벨의 메모리 -> 주소로 참조 가능한 연속적인 바이트들,,
- 하이레벨로 오면? -> 주소 to Value
- 우리의 K언어에서 Value는 Z + B, 변수는 addr, 메모리는 addr -> val
- (M, E, v) 와 (M, S, M')에 대한 추론규칙들을 
- 슬라이드의 스타일을 "Operational Semantics"(과정을 드러내는 의미구조) 라고 함.
- 추론과정, 증명 나무, 이런 것들은 기계적인 계산과 본질이 같다.
- 논리설계에서 그랬듯이, 튜링머신이 그랬듯이, 프로그래밍 언어를 구성하는 구성품도 본질적으로는 아주 간단하다.
- 기계적인 계산 = 튜링기계, 튜링기계가 아주 간단했기 떄문에 튜링기계의 작동도 튜링기계가 될 수 있었다.

4. 변수의 정의에 대한 비판적 접근,,
- 변수라는 것이, Expression 내부에서는 값을 가리키고, x := E에서는 주소를 가리킨다.
- 변수라는 단어의 정의대로, 기계의 상태를 나타내기 때문에 중간중간 그 값은 변화한다. 이건 프로그램을 이해하기 어렵게 만든다.
- 변수가 = string -> location 인게 맞을까? 그렇다면 변수의 유효범위가 프로그램 전체? -> 같은 이름을 허용할 수 없음.
=> Env와 바인딩
- 변수의 유효범위를 지정하면, 같은 이름의 변수로 여러 location을 표현할 수 있다. ( 'in', {} 등의 문법,, )
- 불변성, 함수형 프로그래밍에 대한 강조,, (수학을 하던 시절에, 연산의 결과로 인해서 문자의 값이 변하지는 않는다는 말.)  
=> Env나 Mem도, 새로운 값을 만들어서 반환할 뿐임
- 새롭게 만들어서 리턴하는 방식의 비효율성, redundancy? -> Garbage collection, 불변성에 기반한 Sharing
=> 트리 형태를 이용, 한쪽 spine만 복사하고 나머지는 pointing하도록 구현함.
- 성능보다 안전성, 안정성, Guarantee가 중요한 시대가 되었다.
- 변수는 묶여있을 수도, 자유로울 수도 있다. (bind)

5. 프로시저
- 프로그램 코드에 이름을 붙인 것을 프로시저(procedure or label)라고 함.
- 쟁점 1. 어디에 선언될지 -> 언어 by 언어죠,, C언어는 top level에서만.
- 쟁점 2. 프로시저 내부의 자유로운 이름들을 어떻게 할지.
- 자유 변수의 바인딩 규칙 -> Dynamic scope vs Static scope
=> 안전성과 guarantee의 시대, Static scope가 살아남았다.
=> 과거엔 Dynamic했음. 구현이 쉬웠거든,,
- Procedure: Id x C로 정의되면 이건 dynamic scoping임.
- 우린 static scope을 원하니까, procedure = Id x C x Env로 정의한다. => 이름의 실체는 실행 전에 결정되어야!
- 제작자의 책임이자 실행자의 안전임,,

6. 인터프리터
- CPU는 본질적으로 기계어를 위한 인터프리터, 전깃줄의 배열로 짜였다.
- K--의 인터프리터를 어셈블리로 짜고, 그 인터프리터를 CPU가 돌린다. -> 두 개의 기어가 맞물려 돌아간다.
- 번역기가 있다면, 한 개의 기어로만 돌리니 더 빠르겠죠,,
- 부트스트랩! 늘 궁금했던 것,,

7. Call-by-value vs Call-by-reference
- f(E)에서 E를 계산한 후 바인딩 -> 이건 call by value임.
- 메모리 주소를 전달해주고 싶다면?
- call-by-ref -> 한 메모리 주소에 대한 alias(별칭)가 생김. 

8. 모든 Command는 Expression이다.
- 함수가 값을 반환하도록 시멘틱을 짜기 위해,,

9. 재귀 함수를 위하여
- 함수 안에서 함수 자신에 대한 정보를 알고 있어야 재귀 호출이 가능함.
- 호출 시에 클로저를 캡처하는데, 이때 그 함수에 대한 메타적인 정보까지 가져가야 한다.

10. 변수의 라이프타임
- 메모리는 중요하니까,, 메모리가 부족하면 컴퓨터에서 피가 나요. 프로그램이 터져요.
- 다 쓴 메모리는 기계에 의해서는(런타임) 사람에 의해서든(컴파일 타임) 회수되도록 해야한다.
- K--까지는 문제없음, 변수의 범위가 정적이라서  

11. Question. K--로 트리를 진짜 만들 수 있습니까? 레코드 없이?
- pair를 구현하면 nested pair로 임의의 레코드를 구현 가능함.
- pair는 함수로 구현할 수 있음. 이건 Ocaml 과제에서도 계속 등장하던 아이디어임,, (pair a b -> 1, 2를 받는 함수)

12. K-- with Record: 키:밸류의 메모리 뭉치
- K언어에서는 Record: Field -> Addr
- 동적 할당된 메모리 주소의 라이프타임을 항상 정확하게 계산하는 것은 불가능,,
- K--에 프로시저, 재귀, 레코드를 붙여서 K-,,

13. K- 돌아보기.
- 형식적으로는 말이 되는데, 의미상 말이 안 되는 프로그램들
- 타입이 안 맞는 상황들, 의미가 정의되지 않은 문장들.
- 문법에 맞는 프로그램의 집합 안에 의미가 정의된 프로그램이 있는데, 의미가 정의된 프로그램 집합의 크기가 훨씬 더 작다.
- 의미가 없는 프로그램을 실행하기 전에 미리 잡아내고 싶다!

14. 좋은 기술이란 완전한, integral한 기술이다,, 파싱은 비교적 쉽지만, 어쨌든 좋은 기술이다.

15. 타입 체킹
- 프로그램이 의미 있는지를 결정하는 방법
- 정적 타입 체킹은 아주 어려운 과제이자 넘어야 할 산임.
- 동적 타입 체킹은 쉽지만, 덜 유의하다.
- Sound & Complete -> Impossible,, usually.
-> Soundness (타당성)	"타입이 맞다고 한 건 진짜 실행해도 문제 없다." → 안전함 보장
-> Completeness (완전성)	"실행에 문제가 없는 프로그램은 모두 타입 검사에서 통과할 수 있다." → 거짓 양성 없음
- 프로그램의 possibility를 판단하는 방법 -> 멈춤 문제로 건너풀기 sound & complete한 타입체커 A에 대해서, 임의의 pgm을 받아 pgm; 1+true를 A에 넣으면 멈추는지를 간접적으로 판단해줌, crash = 안끝난다는 뜻임..
- 적당히 양보하자. 더 깐깐해질수도, 더 느슨해질수도
- 요즘 세상에선,,, 깐깐하되, 최대한 정확한 판단을 내려주는 타입 체커를 만들어야 한다.
- K-는 타입 체킹에 대한 고려가 전혀 없이 고안된 언어, 제대로 깐깐하지도, 느슨하지도 못한 모자란 타입체킹이 될 수 밖에,,

16. K언어를 향하여,,
- Logic과 Computation: syntax definition <-> parser / semantic definition <-> interpreter // K-까지,,
- 타입 시스템을 위해서는? type checking rules <-> type checking procedure
- 타입은 본질적으로 베이스 타입들의 논리곱과 논리합으로 정의됨. 그래서 타입체크 룰들이 가정과 결론 형태의 추론식으로 구성되는거임!
- 슬라이드에서 or에 대한 추론식이 case / imply에 대한 추론식이 function call
- 수만을 계산하는 프로그램에서, even과 odd라는 타입을 정의.
- 변수의 타입을 어케 쫓아가냐? 그것도 env를 이용하면 됨. 
- K언어는 monotype - 다형성을 지원하지 않는.

