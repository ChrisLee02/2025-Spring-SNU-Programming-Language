1. 돌아보기, 내다보기
- 지금까지 배운 것: 프로그램의 구조와 의미(Abstract syntax, Semantics), 그것을 표현하기 위한 귀납법과 그 철학을 따르는 프로그래밍 방법.
- 앞으로 배울 것: 기계 중심의 언어와 값 중심의 언어

2. 프로그래밍 언어의 두 토양: 튜링 기계와 람다 계산
- 튜링 기계를 전자 부품으로 구현한 컴퓨터 - 종이 테이프, 상태, 규칙표로 구성된,,
- 튜링 기계로 임의의 튜링 기계를 돌릴 수 있다. 보편만능의 기계
- 튜링 기계를 돌리기 위한 기계 중심의 언어(imperative language)는 종이 테이프에 뭘 쓰고 바꾸고 하는 방식으로 동작할 수 밖에,, C언어는 return 값보다는 인자로 전달한 포인터의 값을 변경하는 식으로 작동하잖아?
- 1936년 같은 시기, 람다 계산법이 등장함
- 람다 계산법에 기초한 값 중심의 언어(applicative language)에는 기계가 없다. 상태의 변화도 없다.
- 값을 내놓을 뿐,,
- 두 패러다임의 좋은 점들이 섞이면서 프로그래밍 하기 좋은 언어로 수렴해간다. 나비가 꽃을 향해 날아가듯,,

3. 기계중심의 언어
- 명령, 흐름, statement와 기계의 상태
- 주어진 메모리 M에 대해서 Expression은 값(V)을 계산하고, 메모리는 바꾸지 않음.
- 주어진 메모리 M에 대해서 Statement(명령문)는 메모리 M을 M'으로 변화시킨다.
- Syntactic object(E, S) -> 프로그램의 구조를 정의, Semantic object(M, v) -> 프로그램의 의미를 정의
- record를 함수로 표현하는 방법이 슬라이드에 나와있었음,, f[b/a] or f{a -> b}
- 전기적 레벨의 메모리 -> 주소를 받아서 0/1을 주거나 쓸 수 있는 회로 (Capacitor)
- 시스템 레벨의 메모리 -> 주소로 참조 가능한 연속적인 바이트들,,
- 하이레벨로 오면? -> 주소 to Value
- 우리의 K언어에서 Value는 Z + B, 변수는 addr, 메모리는 addr -> val
- (M, E, v) 와 (M, S, M')에 대한 추론규칙들을 
- 슬라이드의 스타일을 "Operational Semantics"(과정을 드러내는 의미구조) 라고 함.
- 추론과정, 증명 나무, 이런 것들은 기계적인 계산과 본질이 같다.
- 논리설계에서 그랬듯이, 튜링머신이 그랬듯이, 프로그래밍 언어를 구성하는 구성품도 본질적으로는 아주 간단하다.
- 기계적인 계산 = 튜링기계, 튜링기계가 아주 간단했기 떄문에 튜링기계의 작동도 튜링기계가 될 수 있었다.

4. 변수의 정의에 대한 비판적 접근,,
- 변수라는 것이, Expression 내부에서는 값을 가리키고, x := E에서는 주소를 가리킨다.
- 변수라는 단어의 정의대로, 기계의 상태를 나타내기 때문에 중간중간 그 값은 변화한다. 이건 프로그램을 이해하기 어렵게 만든다.
- 변수가 = string -> location 인게 맞을까? 그렇다면 변수의 유효범위가 프로그램 전체? -> 같은 이름을 허용할 수 없음.
=> Env와 바인딩
- 변수의 유효범위를 지정하면, 같은 이름의 변수로 여러 location을 표현할 수 있다. ( 'in', {} 등의 문법,, )
- 불변성, 함수형 프로그래밍에 대한 강조,, (수학을 하던 시절에, 연산의 결과로 인해서 문자의 값이 변하지는 않는다는 말.)  
=> Env나 Mem도, 새로운 값을 만들어서 반환할 뿐임
- 새롭게 만들어서 리턴하는 방식의 비효율성, redundancy? -> Garbage collection, 불변성에 기반한 Sharing
=> 트리 형태를 이용, 한쪽 spine만 복사하고 나머지는 pointing하도록 구현함.
- 성능보다 안전성, 안정성, Guarantee가 중요한 시대가 되었다.
- 변수는 묶여있을 수도, 자유로울 수도 있다. (bind)

5. 프로시저
- 프로그램 코드에 이름을 붙인 것을 프로시저(procedure or label)라고 함.
- 쟁점 1. 어디에 선언될지 -> 언어 by 언어죠,, C은 top level에서만.
- 쟁점 2. 프로시저 내부의 자유로운 이름들을 어떻게 할지.
- 자유 변수의 바인딩 규칙 -> Dynamic scope vs Static scope
=> 안전성과 guarantee의 시대, Static scope가 살아남았다.
=> 과거엔 Dynamic했음. 구현이 쉬웠거든,,
- Procedure: Id x C로 정의되면 이건 dynamic scoping임.
- 우린 static scope을 원하니까, procedure = Id x C x Env로 정의한다. => 이름의 실체는 실행 전에 결정되어야!
- 제작자의 책임이자 실행자의 안전임,,

6. 인터프리터
- CPU는 본질적으로 기계어를 위한 인터프리터, 전깃줄의 배열로 짜였다.
- K--의 인터프리터를 어셈블리로 짜고, 그 인터프리터를 CPU가 돌린다. -> 두 개의 기어가 맞물려 돌아간다.
- 번역기가 있다면, 한 개의 기어로만 돌리니 더 빠르겠죠,,
- 부트스트랩! 늘 궁금했던 것,,

7. Call-by-value vs Call-by-reference
- f(E)에서 E를 계산한 후 바인딩 -> 이건 call by value임.
- 메모리 주소를 전달해주고 싶다면?
- 



