1. 돌아보기, 내다보기
- 지금까지 배운 것: 프로그램의 구조와 의미(Abstract syntax, Semantics), 그것을 표현하기 위한 귀납법과 그 철학을 따르는 프로그래밍 방법.
- 앞으로 배울 것: 기계 중심의 언어와 값 중심의 언어

2. 프로그래밍 언어의 두 토양: 튜링 기계와 람다 계산
- 튜링 기계를 전자 부품으로 구현한 컴퓨터 - 종이 테이프, 상태, 규칙표로 구성된,,
- 튜링 기계로 임의의 튜링 기계를 돌릴 수 있다. 보편만능의 기계
- 튜링 기계를 돌리기 위한 기계 중심의 언어(imperative language)는 종이 테이프에 뭘 쓰고 바꾸고 하는 방식으로 동작할 수 밖에,, C언어는 return 값보다는 인자로 전달한 포인터의 값을 변경하는 식으로 작동하잖아?
- 1936년 같은 시기, 람다 계산법이 등장함
- 람다 계산법에 기초한 값 중심의 언어(applicative language)에는 기계가 없다. 상태의 변화도 없다.
- 값을 내놓을 뿐,,
- 두 패러다임의 좋은 점들이 섞이면서 프로그래밍 하기 좋은 언어로 수렴해간다. 나비가 꽃을 향해 날아가듯,,

3. 기계중심의 언어
- 명령, 흐름, statement와 기계의 상태
- 주어진 메모리 M에 대해서 Expression은 값(V)을 계산하고, 메모리는 바꾸지 않음.
- 주어진 메모리 M에 대해서 Statement(명령문)는 메모리 M을 M'으로 변화시킨다.
- Syntactic object(E, S) -> 프로그램의 구조를 정의, Semantic object(M, v) -> 프로그램의 의미를 정의
- record를 함수로 표현하는 방법이 슬라이드에 나와있었음,, f[b/a] or f{a -> b}
- 전기적 레벨의 메모리 -> 주소를 받아서 0/1을 주거나 쓸 수 있는 회로 (Capacitor)
- 시스템 레벨의 메모리 -> 주소로 참조 가능한 연속적인 바이트들,,
- 하이레벨로 오면? -> 주소 to Value
- 우리의 K언어에서 Value는 Z + B, 변수는 addr, 메모리는 addr -> val
- (M, E, v) 와 (M, S, M')에 대한 추론규칙들을 
- 슬라이드의 스타일을 "Operational Semantics"(과정을 드러내는 의미구조) 라고 함.
- 추론과정, 증명 나무, 이런 것들은 기계적인 계산과 본질이 같다.
- 논리설계에서 그랬듯이, 튜링머신이 그랬듯이, 프로그래밍 언어를 구성하는 구성품도 본질적으로는 아주 간단하다.
- 기계적인 계산 = 튜링기계, 튜링기계가 아주 간단했기 떄문에 튜링기계의 작동도 튜링기계가 될 수 있었다.

4. 변수의 정의에 대한 비판적 접근,,
- 변수라는 것이, Expression 내부에서는 값을 가리키고, x := E에서는 주소를 가리킨다.
- 변수라는 단어의 정의대로, 기계의 상태를 나타내기 때문에 중간중간 그 값은 변화한다. 이건 프로그램을 이해하기 어렵게 만든다.
- 변수가 = string -> location 인게 맞을까? 그렇다면 변수의 유효범위가 프로그램 전체? -> 같은 이름을 허용할 수 없음.
=> Env와 바인딩
- 변수의 유효범위를 지정하면, 같은 이름의 변수로 여러 location을 표현할 수 있다. ( 'in', {} 등의 문법,, )
- 불변성, 함수형 프로그래밍에 대한 강조,, (수학을 하던 시절에, 연산의 결과로 인해서 문자의 값이 변하지는 않는다는 말.)  
=> Env나 Mem도, 새로운 값을 만들어서 반환할 뿐임
- 새롭게 만들어서 리턴하는 방식의 비효율성, redundancy? -> Garbage collection, 불변성에 기반한 Sharing
=> 트리 형태를 이용, 한쪽 spine만 복사하고 나머지는 pointing하도록 구현함.
- 성능보다 안전성, 안정성, Guarantee가 중요한 시대가 되었다.
- 변수는 묶여있을 수도, 자유로울 수도 있다. (bind)

5. 프로시저
- 프로그램 코드에 이름을 붙인 것을 프로시저(procedure or label)라고 함.
- 쟁점 1. 어디에 선언될지 -> 언어 by 언어죠,, C언어는 top level에서만.
- 쟁점 2. 프로시저 내부의 자유로운 이름들을 어떻게 할지.
- 자유 변수의 바인딩 규칙 -> Dynamic scope vs Static scope
=> 안전성과 guarantee의 시대, Static scope가 살아남았다.
=> 과거엔 Dynamic했음. 구현이 쉬웠거든,,
- Procedure: Id x C로 정의되면 이건 dynamic scoping임.
- 우린 static scope을 원하니까, procedure = Id x C x Env로 정의한다. => 이름의 실체는 실행 전에 결정되어야!
- 제작자의 책임이자 실행자의 안전임,,

6. 인터프리터
- CPU는 본질적으로 기계어를 위한 인터프리터, 전깃줄의 배열로 짜였다.
- K--의 인터프리터를 어셈블리로 짜고, 그 인터프리터를 CPU가 돌린다. -> 두 개의 기어가 맞물려 돌아간다.
- 번역기가 있다면, 한 개의 기어로만 돌리니 더 빠르겠죠,,
- 부트스트랩! 늘 궁금했던 것,,

7. Call-by-value vs Call-by-reference
- f(E)에서 E를 계산한 후 바인딩 -> 이건 call by value임.
- 메모리 주소를 전달해주고 싶다면?
- call-by-ref -> 한 메모리 주소에 대한 alias(별칭)가 생김. 

8. 모든 Command는 Expression이다.
- 함수가 값을 반환하도록 시멘틱을 짜기 위해,,

9. 재귀 함수를 위하여
- 함수 안에서 함수 자신에 대한 정보를 알고 있어야 재귀 호출이 가능함.
- 호출 시에 클로저를 캡처하는데, 이때 그 함수에 대한 메타적인 정보까지 가져가야 한다.

10. 변수의 라이프타임
- 메모리는 중요하니까,, 메모리가 부족하면 컴퓨터에서 피가 나요. 프로그램이 터져요.
- 다 쓴 메모리는 기계에 의해서는(런타임) 사람에 의해서든(컴파일 타임) 회수되도록 해야한다.
- K--까지는 문제없음, 변수의 범위가 정적이라서  

11. Question. K--로 트리를 진짜 만들 수 있습니까? 레코드 없이?
- pair를 구현하면 nested pair로 임의의 레코드를 구현 가능함.
- pair는 함수로 구현할 수 있음. 이건 Ocaml 과제에서도 계속 등장하던 아이디어임,, (pair a b -> 1, 2를 받는 함수)

12. K-- with Record: 키:밸류의 메모리 뭉치
- K언어에서는 Record: Field -> Addr
- 동적 할당된 메모리 주소의 라이프타임을 항상 정확하게 계산하는 것은 불가능,,
- K--에 프로시저, 재귀, 레코드를 붙여서 K-,,

13. K- 돌아보기.
- 형식적으로는 말이 되는데, 의미상 말이 안 되는 프로그램들
- 타입이 안 맞는 상황들, 의미가 정의되지 않은 문장들.
- 문법에 맞는 프로그램의 집합 안에 의미가 정의된 프로그램이 있는데, 의미가 정의된 프로그램 집합의 크기가 훨씬 더 작다.
- 의미가 없는 프로그램을 실행하기 전에 미리 잡아내고 싶다!

14. 좋은 기술이란 완전한, integral한 기술이다,, 파싱은 비교적 쉽지만, 어쨌든 좋은 기술이다.

15. 타입 체킹
- 프로그램이 의미 있는지를 결정하는 방법
- 정적 타입 체킹은 아주 어려운 과제이자 넘어야 할 산임.
- 동적 타입 체킹은 쉽지만, 덜 유의하다.
- Sound & Complete -> Impossible,, usually.
-> Soundness (타당성)	"타입이 맞다고 한 건 진짜 실행해도 문제 없다." → 안전함 보장
-> Completeness (완전성)	"실행에 문제가 없는 프로그램은 모두 타입 검사에서 통과할 수 있다." → 거짓 양성 없음
- 프로그램의 possibility를 판단하는 방법 -> 멈춤 문제로 건너풀기 sound & complete한 타입체커 A에 대해서, 임의의 pgm을 받아 pgm; 1+true를 A에 넣으면 멈추는지를 간접적으로 판단해줌, crash = 안끝난다는 뜻임..
- 적당히 양보하자. 더 깐깐해질수도, 더 느슨해질수도
- 요즘 세상에선,,, 깐깐하되, 최대한 정확한 판단을 내려주는 타입 체커를 만들어야 한다.
- K-는 타입 체킹에 대한 고려가 전혀 없이 고안된 언어, 제대로 깐깐하지도, 느슨하지도 못한 모자란 타입체킹이 될 수 밖에,,

16. K언어를 향하여,,
- Logic과 Computation: syntax definition <-> parser / semantic definition <-> interpreter // K-까지,,
- 타입 시스템을 위해서는? type checking rules <-> type checking procedure
- 타입은 본질적으로 베이스 타입들의 논리곱과 논리합으로 정의됨. 그래서 타입체크 룰들이 가정과 결론 형태의 추론식으로 구성되는거임!
- 슬라이드에서 or에 대한 추론식이 case / imply에 대한 추론식이 function call
- 수만을 계산하는 프로그램에서, even과 odd라는 타입을 정의.
- 변수의 타입을 어케 쫓아가냐? 그것도 env를 이용하면 됨. 
- K언어는 monotype - 다형성을 지원하지 않는.
- 선언 시점의 타입을 고정하도록 해야 한다. (c에서의 자료형처럼)
- 정지 문제를 푸는 소프트웨어는 없다(마찬가지로, 실행 전에 값을 미리 알 수 있는 프로그램도 없다.) - 논증: f(X) = if H(x, x) then while true (unit) else 1
 -> x = f의 코드(f_)를 집어넣어서 f(f_) = if H(f_,f_) then ... 으로 가면 모순이 발생한디ㅣㅣ
- 대각선 논법 -> 1. 소프트웨어 집합의 크기는 자연수 집합의 크기 2. 인풋 집합의 크기도 자연수 집합의 크기 3. 2차원 격자에 소프트웨어와 인풋을 배치, 끝나면 다른 값을 뱉도록, 안끝나면 끝나도록 하면 모든 소프트웨어와 다른 소프트웨어가 존재함. 이는 모순이다,,
- if문의 반환 타입을 맞추는 이유는 값을 미리 알 수 없기 때문,, -> valid한 프로그램 중 상당수를 잡아내지 못하게 됨.
- K언어 -> 프로그래머에게 타입을 명시하도록 요구하는 언어.. 이제는 C언어를 많이 닮았다. (변수의 자료형, 함수 반환타입 명시,,)

17. Beyond the K
- Type Safety: Let E be a program. If E is type-checked OK, then it does not go wrong.
- 더 엄밀하게,, Let E be a program. If {} |- E: t then E does not go wrong
- 더더 엄밀하게,, Let E be a program. If {} |- E : t then 돌렷({},{},E) runs OK.

18. Memory management
- 메모리는 유한하다. 다 쓰면 회수하여 재활용해야한다.
- 누가 메모리를 재활용해야할까? 프로그래머? 프로그램?
- 프로그래머가 한다면, memory leak(너무 늦은 free), dangling pointer(너무 이른 free) 문제가 발생할 수 있다.
- 프로그램이 자동으로 메모리를 재활용한다면 (Garbage collection) 오버헤드가 생긴다. 
- 메모리가 더 이상 안 남아있는 시점에 memory footprint를 보고 안 쓰는걸 주워온다.
- 완벽한 가비지 컬렉션은 타입 시스템과 마찬가지로 불가능하다.
- 애매한거 말고, 절대로 안 쓰이는 메모리 공간을 찾는 방법은 있지 않을까?
- Env의 모든 키값에 대해 Mem로 가고, Mem에서 또 레코드로 타고 들어가는 과정을 재귀적으로 끝까지 해서 구한 집합을 뺀다.
- 그러면 "절대로 안 쓰이는 메모리 공간을 찾을 수 있다"
- 그래프로 메모리 공간을 표현해서 탐색해나간다,,
- Mark & sweep, Env에서의 주소값을 루트로 해서 DFS or BFS를 돌려서 mark, mark되지 않은 놈들을 sweep.
- DFS랑 BFS를 위한 메모리는 조상님이 주시냐?
-> 그래프에다가 추가비트를 할당, edge의 방향을 바꾸는 식으로(추가 flag와 함께) 구현 가능함.
- 아니 근데, Env 기반으로 GC를 하는건 이상한거 아님? 바깥으로 다시 나와서 쓸 수도 있을텐데? -> 맞음. 그래서 Env만 봐서는 안 됨.
- 아무튼, GC를 꿈꾸고 만들어낸 사람들의 마인드를 본받아라. 불가능을 말하는 이론을 경청하고 그 불가능에 타협해내기 위해 고민하기.
- "다 덤벼" "개뿔" "chutzpah spirit" 정신을 갖도록 해라!
- mark & sweep -> 위에서 언급한거 // stop & copy -> 절반의 메모리를 따로 빼놓고, 재활용 시점에 locality를 살려서 옮겨놓기 - 캐싱이나 파편화 문제에 유리함.
- 주류는 mark & sweep
- 10ms의 벽을 넘기 위한 시도? 방금 막 할당된 놈은 일찍 죽을 가능성이 높음, 살아있던 놈은 계속 살아있을 가능성이 높음. -> 방을 나눠놓고, 최근에 할당된 놈들부터 가비지 컬렉팅을 시도
- 로우레벨로 옮겨놓으면(메모리를 직접 다루면) 가비지 컬렉팅을 하기가 더 편하다. 그리고 변수명은 그 시점에 다 다르게 만들어놔야 문제가 안생긴다..(질문했던 내용) static link가 env의 역할을 한다. 

19. Part 0, 1을 돌아보면,,
- 귀납적 사고. 그 사고에 기반한 언어의 형식과 의미, 타입의 형식과 의미 정의하기
- 명령형 언어 디자인: K-, K
- 이름은 무엇을 가지는가: 위치, 함수, 타입,,
- 변수의 범위 / 재귀 / 인자 전달 / 타입 체크, 안전성 / "타입 동치, 오버로딩, 네임스페이스"(들을 배웠나? 흠,,)

20. 번역과 가상머신
- 가상머신 = 전깃줄로 만들어지지 않은 기계.
- 번역 -> 의미를 보존한 채로 형식을 바꾸기
(Q&A:모든 프로그램 페어에 대해 "자동으로" 두 프로그램이 같냐를 판단하는건 불가능,, 번역과는 관련없음.)
"과학은 안심시킨다." 
"예술은 동요시킨다." 
"공학은 만족시킨다."
- 번역의 원칙 - 불변성질(invariant), 조립식. Translation = a game of invariant!!
- 최적화를 시도하는 컴파일러는 일부분 못미덥다. 

21. K- 인터프리터의 한계점
- 모듈 프로그래밍을 지원하지 않음 & 언어 간 Operability를 지원하지 않음.

PART 1 完