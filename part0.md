1. 프로그래밍 언어란 무엇인가?
- 튜링 머신, 기계적인 계산의 정의로부터 뒤따라오는 규칙 표
- 규칙 표와 해석 기계
- 프로그래밍 언어와 기계의 관계,, 기계가 언어를 돌리기 위해 만들어졌다? 언어가 기계를 위해 고안되었다?
- 프로그래밍 언어의 '해석기'의 구조를 배우기 위한 과목들을 들어왔다,,,
- '언어'가 어떻게 생긴 것인지 의미구조를 정의할 수 있는지, 언어 내부의 여러가지 요소들과 데이터 구조를 정의할 수 있는지,, 

2. 프로그래밍 언어를 어떻게 정의할까?
- 프로그래밍 언어의 정의는 유한한 크기를 가지나,
- 그로부터 작성되는 프로그램의 개수는 무한하다.
- 자연수 집합의 정의와 유사하게 프로그래밍 언어로부터 작성되는 프로그램의 집합을 정의할 수 있다.
- X가 집합의 원소일 때 ~~~이다. 라는 식의 가정과 결론을 '|' 또는 'ㅡ'를 이용한 형태로 표현할 수 있다.
- 리스트, 트리, 그래프들을 Inductive하게 정의하는 것도 가능할 것 -> 빈틈없이, 제대로 정의할 수 있는 유용한 도구이다!
- 잘 정의된 것은 그 자체로 빈틈없다. 순환논리, 혹은 베이스케이스에 도달하지 못하는 정의는 조건에 불과하다.

3. Abstract Syntax  
- Abstraction의 의미는? -> 요약하기 / 핵심 드러내기 / 속내용 감추기 // + 머리속으로 궁리하기,,
- Abstract Syntax -> 문법에서 핵심만 간추리기 (읽는 사람을 위한 내용은 빼고, 의미와 연관되는 핵심만.)
- 일종의 트리로 표현될 수 있다.
- 말/글은 1차원의 실이지만, 의미구조는 2차원의 트리로 표현된다.
- Concrete Syntax는 1차원의 실에서의 문법, 파싱을 통해 Abstract Syntax로 변환된다.  

=== Q. 컴퓨터랑 언어랑 같이 나온거 아님?
=> 기계적, 전기적인 컴퓨터보다 그 설계도이자 언어가 먼저라는 말임,,

=== Q. 컴퓨터로 풀 수 있는 문제는? // 풀 수 없는 문제가 있다,, N -> 2^N으로 가는 문제는 못푼다(멈춤 문제)
=> 멈춤 문제에 대한 "적당한" 해결책을 찾으려는게 프로그래밍 언어 설계의 과제임.

4. Semantics
- '='을 이용한다고 다 semantics는 아님. 자기 자신을 통해 정의하려고 들면 그건 방정식, specification이지 정의가 아니다.
- 부품으로 전체를 설명하는 것이 정의임.
- 부분 논리식(Propositional logic), 술어 논리(모든 것과 어떤 것에 대한 논리식, Predicate logic), 
- 집합 A, B에 대해서,, 집합으로 집합을 만드는 연산: A x B, A + B, A -> B
- 튜링기계도, 람다 캘률러스에도 변수가 있음,, 변수가 없는 3번째 기계적 계산의 정의: combinatorial logic
- Env: 변수 이름의 실체는 어떻게 결정되는가? 그건 환경에 따라 달라짐. str -> addr
- 이 Env를 도입하면, 모든과 어떤에 대한 의미를 Env를 이용해서 정의할 수 있음.
- 변수에 대해서 뭔가를 정의하기 위한게 Env라는거,,

5. 다시 돌아와서, 귀납법
- "가장 작은 집합"을 정의하는 방법 -> 규칙에 대해서 닫혀있는 집합들을 싹다 교집합 때려버리면 된다!
- 베이스 집합을 받아서 규칙을 적용하여 집합을 반환하는 함수에 대해, X를 넣어서 X의 부분집합이 되는 집합이 나오도록 하는
- 그런 인풋 X들의 교집합이 최소고정점이 된다...
- 그런 집합을 실제로 만들어내는 기계적인 과정은 무엇인가? -> 공집합에서부터 시작하여 규칙을 반복적으로 적용하여 만들어낸 파이^0, 파이^1, ... 을 모두 합집합한다.
- 유한한 요소로 무한을 정의하는 방법으로서의 귀납법 -> 닫혀있는 최소의 집합의 정의 및 생성의 방법을 배움.
- 무한한 집합에 대한 증명 방법으로서의 귀납법 -> ex. 완전이진트리에 대한 귀납증명,, -> 컴파일러, 랭귀지 도우미의 유용성을 증명합니다.
- 논리 집합을 추론 규칙으로 정의를 하면, 그 내부의 semantics를 몰라도 기계적으로 계산 가능
 => 컴파일러도 이와 유사함. 프로그램을 돌리지 않고 추론 규칙, 껍데기만으로 최종 결과가 YES(잘 끝나는지)인지 확인해준다. 귀납법귀납법귀납법아주중요하게쓰인다~~~~
 => 모든 프로그램에 대해서, 컴파일러가 그 프로그램에 대해 yes라고 말하는 것과 그 프로그램이 좋은 것이 동치가 될 수 있을까? 그렇지 않은 경우에는 조건을 완화해야한다. 모든 프로그램을 양보하거나, yes를 완화하거나, 동치관계를 포기하거나.
- 완전성과 안전성

=== Quote: 컴퓨타 싸이언스란 무엇인가,, 
=> 1. Mechanization of Abstraction 
=> 2. Science of Intelligence
=> 생각을 해야 하는데, 생각할 근육은 있으신지요? 수학과 과목을 들어보세요..




